<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FPS Converter Hub — FCH (Pro Micro/Macro)</title>

  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icon.svg" type="image/svg+xml">
  <meta name="theme-color" content="#19a6ff">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="app" class="app" aria-hidden="false" style="display:block;">
    <header class="header" role="banner">
      <div class="left">
        <div class="logo" aria-hidden="true">FCH</div>
        <div>
          <h1 class="title">FPS Converter Hub</h1>
          <div class="sub small">Mobile-first • Controller • Micro/Macro analysis</div>
        </div>
      </div>
      <div class="right">
        <button id="installBtn" class="btn-ghost small" aria-label="Install" style="display:none">Install</button>
      </div>
    </header>

    <main class="main" role="main">
      <section class="card">
        <label class="small">Base Game</label>
        <select id="src_game" class="input" aria-label="Base Game"></select>

        <label class="small">Base Curve (default)</label>
        <select id="src_curve" class="input" aria-label="Base Curve"></select>

        <div class="pair">
          <input id="src_h" class="input half" type="number" value="7" step="any" aria-label="Horizontal sens">
          <input id="src_v" class="input half" type="number" value="7" step="any" aria-label="Vertical sens">
        </div>

        <label class="small">FOV</label>
        <input id="src_fov" class="input" type="number" value="90" aria-label="Field of view" />

        <label class="small checkbox"><input id="adsToggle" type="checkbox"> Include ADS conversion</label>
        <div id="adsFields" class="adsFields hidden">
          <input id="ads_src" class="input" type="text" placeholder=".80 or 80" />
        </div>
      </section>

      <section class="card">
        <label class="small">Target Game</label>
        <select id="tgt_game" class="input" aria-label="Target Game"></select>

        <div style="height:10px"></div>
        <button id="convertBtn" class="btn">Convert</button>
        <div style="height:10px"></div>

        <div style="display:flex;gap:8px;align-items:center">
          <button id="showGraphBtn" class="btn-ghost">Show Graph</button>
          <button id="compareBtn" class="btn-ghost hidden">Compare (Pro)</button>
        </div>
      </section>

      <section class="card">
        <div class="row-between">
          <strong>Conversion Output</strong>
          <div class="small" id="modeTag">Exact Ratio-Based</div>
        </div>

        <div style="height:8px"></div>
        <pre id="output" class="result">Tap Convert</pre>

        <div style="height:10px"></div>
        <button id="advToggle" class="btn-ghost">Advanced</button>
        <div id="advPanel" class="card hidden small">
          <div id="advContent" style="white-space:pre-wrap">Advanced info will appear here.</div>
          <div style="height:8px"></div>
          <label class="small">Micro/Macro bias</label>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="microOn" class="btn-ghost small">Micro ON</button>
            <button id="microOff" class="btn-ghost small active">Macro ON</button>
          </div>
          <div class="small" style="margin-top:8px;color:var(--muted)">
            Micro = prioritizes short-range precision. Macro = full-range uniform comparison.
          </div>
        </div>

        <div id="graphWrap" class="graph-wrap hidden" aria-live="polite">
          <div class="compareHeader">
            <div id="microResult" class="microResult">Closest Micro-Aim (Short Range Curve): <span id="microName">—</span></div>
            <div id="macroResult" class="macroResult">Closest Macro-Aim (Full Range Curve): <span id="macroName">—</span></div>
          </div>

          <canvas id="curveCanvas" width="720" height="360" aria-label="Main curve visualization"></canvas>

          <!-- Pro mini compare panels -->
          <div id="miniWrap" class="miniWrap hidden">
            <div class="miniCard">
              <div class="miniLabel">Your Curve</div>
              <canvas id="miniYour" width="360" height="160" aria-label="Your curve"></canvas>
            </div>
            <div class="miniCard">
              <div class="miniLabel">Closest Match</div>
              <canvas id="miniMatch" width="360" height="160" aria-label="Closest curve"></canvas>
            </div>
          </div>

          <div class="legend small" id="curveLegend" style="margin-top:8px"></div>
        </div>
      </section>

      <footer class="footer small">Made by Yeetonio — FPS Converter Hub (Pro)</footer>
    </main>
  </div>

<script>
/* ==================== Data ==================== */
const CURVE_SHAPES = {
  linear:[0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1],
  standard:[0,0.02,0.07,0.16,0.29,0.45,0.61,0.76,0.88,0.96,1],
  dynamic:[0,0.01,0.04,0.09,0.18,0.30,0.48,0.70,0.88,0.97,1],
  exponential:[0,0.006,0.02,0.07,0.16,0.33,0.57,0.79,0.92,0.98,1],
  sinusoidal:[0,0.015,0.05,0.12,0.25,0.45,0.66,0.82,0.92,0.98,1],
  standard_bf6: [0.00,0.02,0.06,0.12,0.22,0.36,0.52,0.70,0.86,0.96,1.00],
  bf2042_old:    [0.00,0.004,0.015,0.040,0.100,0.250,0.500,0.750,0.900,0.980,1.00],
  bfv:           [0.00,0.018,0.055,0.130,0.250,0.430,0.610,0.780,0.890,0.960,1.00],
  bf1_bf4:       [0.00,0.020,0.060,0.140,0.280,0.440,0.610,0.770,0.900,0.960,1.00],
  bf3:           [0.00,0.03,0.09,0.2,0.35,0.52,0.68,0.82,0.91,0.97,1.00],
  bfbc2:         [0.00,0.028,0.075,0.18,0.33,0.5,0.67,0.81,0.9,0.98,1.00],
  bfbc:          [0.00,0.025,0.07,0.16,0.3,0.48,0.66,0.8,0.9,0.97,1.00],
  dynamic_bf6:   [0.00,0.02,0.06,0.14,0.22,0.34,0.56,0.78,0.92,0.98,1.00],
  apex_classic:      [0.00,0.03,0.08,0.16,0.26,0.38,0.52,0.68,0.82,0.92,1.00],
  apex_steady:       [0.00,0.01,0.03,0.06,0.12,0.22,0.36,0.52,0.70,0.88,1.00],
  apex_fine_aim:     [0.00,0.02,0.04,0.07,0.10,0.14,0.18,0.22,0.30,0.40,1.00],
  apex_high_velocity:[0.00,0.18,0.40,0.60,0.78,0.90,0.96,0.98,0.995,0.999,1.00],
  apex_linear:       [0.00,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1.00],
  mw3_linear:   [0.00,0.04,0.09,0.18,0.32,0.50,0.70,0.85,0.94,0.98,1.00],
  mw3_standard: [0.00,0.02,0.06,0.14,0.25,0.40,0.58,0.74,0.88,0.96,1.00],
  mw3_dynamic:  [0.00,0.01,0.04,0.12,0.28,0.46,0.64,0.80,0.92,0.98,1.00]
};

const GAME_CURVES = {
  mw3:['standard','dynamic','linear'],
  warzone:['standard','dynamic','linear'],
  bo6:['standard','dynamic','linear'],
  bo7:['standard','dynamic','linear'],
  the_finals:['linear','exponential','sinusoidal'],
  bf6:['standard','bf2042_old','bfv','bf1_bf4','bf3','bfbc2','bfbc','linear','dynamic'],
  bf2042:['standard','linear','bf4','bf1','bf3','bfbc','bfbc2','bfv','2042_old'],
  valorant:['standard','linear','light','medium','heavy','extreme'],
  apex:['classic','steady','fine_aim','high_velocity','linear'],
  csgo:['standard'],
  r6:['standard'],
  fragpunk:['standard','linearplus'],
  halo:['standard']
};

const GAME_RANGE = {
  mw3:[1,20,1], warzone:[1,20,1], bf6:[1,100,0.01], bf2042:[1,100,0.01],
  bo6:[0.1,4.0,0.05], bo7:[0.1,4.0,0.05], the_finals:[20,750,5], apex:[1,8,1],
  fragpunk:[0.1,10.0,0.1], halo:[1,20,0.5], r6:[1,100,1], valorant:[1,10,0.01], csgo:[1,10,0.01]
};

const GAME_LABELS = {
  mw3: 'MW3', warzone:'WARZONE', bo6:'BO6', bo7:'BO7', the_finals:'THE FINALS',
  bf6:'BATTLEFIELD 6', bf2042:'BATTLEFIELD 2042', valorant:'VALORANT', apex:'APEX',
  csgo:'CS:GO', r6:'R6', fragpunk:'FRAGPUNK', halo:'HALO INFINITE'
};

/* ==================== Helpers ==================== */
function $ (id) { return document.getElementById(id); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* Interpolate 11-sample array to dense x biased toward low inputs */
function sampleCurveDense(arr11){
  const xLow = []; for(let i=0;i<=35;i++){ xLow.push(i/100); } // 0.00..0.35
  const xMid = []; for(let i=4;i<=10;i++){ xMid.push(i/10); }    // 0.4..1.0
  const x = xLow.concat(xMid);
  const arr = [];
  for(let xi=0; xi<x.length; xi++){
    const t = x[xi];
    const idx = t*10; const lo = Math.floor(idx), hi = Math.ceil(idx);
    const v = (lo===hi) ? (arr11[lo]||0) : lerp(arr11[lo]||0, arr11[hi]||0, idx-lo);
    arr.push(v);
  }
  return {x,arr};
}

/* weighted distance: micro emphasis */
function weightedDistance(arrA11, arrB11, microBias=true){
  const sA = sampleCurveDense(arrA11), sB = sampleCurveDense(arrB11);
  const A = sA.arr, B = sB.arr, X = sA.x;
  let sum = 0, wsum = 0;
  for(let i=0;i<X.length;i++){
    const x = X[i];
    let w = 1;
    if(microBias){
      if(x <= 0.15) w = 4;
      else if(x <= 0.35) w = 2;
    }
    const d = (A[i]||0) - (B[i]||0);
    sum += w * d * d;
    wsum += w;
  }
  return Math.sqrt(sum / Math.max(1, wsum));
}

/* find best by micro (weighted) and macro (uniform) separately */
function findClosestMicroMacro(srcGame, srcCurveKey, tgtGame){
  const srcArr11 = getCurveArray(srcGame, srcCurveKey);
  const candidates = GAME_CURVES[tgtGame] || ['linear'];
  let bestMicro=null, bestMacro=null, bestScoreMicro=1e9, bestScoreMacro=1e9;
  candidates.forEach(k=>{
    const cand = getCurveArray(tgtGame, k);
    const sm = weightedDistance(srcArr11, cand, true);
    const su = weightedDistance(srcArr11, cand, false);
    if(sm < bestScoreMicro){ bestScoreMicro = sm; bestMicro = k; }
    if(su < bestScoreMacro){ bestScoreMacro = su; bestMacro = k; }
  });
  return {bestMicro, bestMacro, bestScoreMicro, bestScoreMacro};
}

/* curve array mapping for BF6/APEX/MW3 etc */
function getCurveArray(game, curveKey){
  if(!curveKey) return CURVE_SHAPES.linear;
  if(game==='bf6'){
    const m = { standard:'standard_bf6', bf2042_old:'bf2042_old', bfv:'bfv', bf1_bf4:'bf1_bf4', bf3:'bf3', bfbc2:'bfbc2', bfbc:'bfbc', linear:'linear', dynamic:'dynamic_bf6' };
    return CURVE_SHAPES[m[curveKey] || curveKey] || CURVE_SHAPES.linear;
  }
  if(game==='apex'){
    const m = { classic:'apex_classic', steady:'apex_steady', fine_aim:'apex_fine_aim', high_velocity:'apex_high_velocity', linear:'apex_linear' };
    return CURVE_SHAPES[m[curveKey] || curveKey] || CURVE_SHAPES.linear;
  }
  if(game==='mw3'){
    const m = { standard:'mw3_standard', dynamic:'mw3_dynamic', linear:'mw3_linear' };
    return CURVE_SHAPES[m[curveKey] || curveKey] || CURVE_SHAPES.linear;
  }
  return CURVE_SHAPES[curveKey] || CURVE_SHAPES.linear;
}

/* -------- Sens log helpers (unchanged) -------- */
function logNormalize(value, game){
  const r = GAME_RANGE[game] || [1,100,0.01];
  let v = parseFloat(value); if(isNaN(v)) v = r[0];
  v = Math.max(r[0], Math.min(r[1], v));
  const lnMin = Math.log(r[0]+1), lnMax = Math.log(r[1]+1), lnV = Math.log(v+1);
  return (lnV-lnMin)/(lnMax-lnMin);
}
function logDenormalize(norm, game){
  const r = GAME_RANGE[game] || [1,100,0.01];
  const lnMin = Math.log(r[0]+1), lnMax = Math.log(r[1]+1);
  const lnV = lnMin + norm*(lnMax-lnMin);
  const v = Math.exp(lnV)-1;
  const decimals = (r[1]-r[0]) < 10 ? 2 : 2;
  return parseFloat(Math.max(r[0], Math.min(r[1], v)).toFixed(decimals));
}

function convertController(srcGame,tgtGame,srcSens,srcCurve,srcFov,tgtFov,ads){
  const norm = logNormalize(srcSens, srcGame);
  const baseYaw = {mw3:205,warzone:205,bo6:205,bo7:205,bf6:158,bf2042:158,apex:190,valorant:170,csgo:210,r6:150,fragpunk:180,halo:200,the_finals:178};
  const srcYaw = baseYaw[srcGame] || 180;
  const tgtYaw = baseYaw[tgtGame] || 180;
  const fovFactor = (90/srcFov) / (90/tgtFov);
  let tgtNorm = norm * (srcYaw/tgtYaw) * fovFactor;
  if(ads){
    let a=parseFloat(ads); if(a>1) a=a/100; tgtNorm *= a;
  }
  tgtNorm = Math.max(0, Math.min(1, tgtNorm));
  const tgtSens = logDenormalize(tgtNorm, tgtGame);
  const {bestMicro, bestMacro} = findClosestMicroMacro(srcGame, srcCurve, tgtGame);
  return {tgtSens, tgtNorm, closestMicro: bestMicro, closestMacro: bestMacro, norm};
}

/* ================= UI init ================= */
function populateGames(){
  const s = $('src_game'), t = $('tgt_game'); s.innerHTML=''; t.innerHTML='';
  Object.keys(GAME_CURVES).forEach(g=>{
    const o=document.createElement('option'); o.value=g; o.textContent = GAME_LABELS[g] || g.toUpperCase(); s.appendChild(o);
    const o2=document.createElement('option'); o2.value=g; o2.textContent = GAME_LABELS[g] || g.toUpperCase(); t.appendChild(o2);
  });
}
function populateCurves(game, elId){
  const el = $(elId); if(!el) return; el.innerHTML='';
  (GAME_CURVES[game]||['linear']).forEach(k=>{
    const o=document.createElement('option'); o.value=k; o.textContent = k.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase()); el.appendChild(o);
  });
}

document.addEventListener('DOMContentLoaded', ()=>{
  populateGames();
  populateCurves($('src_game').value,'src_curve');
  populateCurves($('tgt_game').value,'tgt_curve');
  $('app').style.display='block';
});

/* ===== UI events ===== */
$('src_game').addEventListener('change', e=> populateCurves(e.target.value,'src_curve'));
$('tgt_game').addEventListener('change', e=> populateCurves(e.target.value,'tgt_curve'));
$('adsToggle').addEventListener('change', e=> $('adsFields').classList.toggle('hidden', !e.target.checked));

$('convertBtn').addEventListener('click', ()=>{
  const src=$('src_game').value, tgt=$('tgt_game').value, srcCurve=$('src_curve').value;
  const h=parseFloat($('src_h').value)||0, v=parseFloat($('src_v').value)||0, fov=parseFloat($('src_fov').value)||90;
  const avg=(h+v)/2; const ads = $('adsToggle').checked ? $('ads_src').value : null;
  const res = convertController(src,tgt,avg,srcCurve,fov,90,ads);
  $('output').textContent = `Source: ${GAME_LABELS[src]||src.toUpperCase()} (${srcCurve}) — Avg ${avg}\nNormalized: ${res.norm.toFixed(4)}\nTarget: ${GAME_LABELS[tgt]||tgt.toUpperCase()}\nSuggested Sens: ${res.tgtSens}`;
  $('advContent').textContent = `Normalized (0-1): ${res.norm.toFixed(4)}\nClosest Micro-Aim: ${res.closestMicro}\nClosest Macro-Aim: ${res.closestMacro}`;
  $('microName').textContent = (res.closestMicro||'—').replace(/_/g,' ').toUpperCase();
  $('macroName').textContent = (res.closestMacro||'—').replace(/_/g,' ').toUpperCase();

  // color accents
  $('microResult').classList.add('visible'); $('macroResult').classList.add('visible');
  updateCompareAvailability();
});

/* ================ Drawing ================ */
const canvas = $('curveCanvas'), ctx = canvas.getContext('2d');
const miniYour = $('miniYour'), ctxYour = miniYour.getContext('2d');
const miniMatch = $('miniMatch'), ctxMatch = miniMatch.getContext('2d');

function drawGrid(ctxLocal, W, H, pad){
  ctxLocal.fillStyle = '#04101a'; ctxLocal.fillRect(0,0,W,H);
  ctxLocal.strokeStyle = 'rgba(255,255,255,0.04)'; ctxLocal.lineWidth = 1;
  for(let i=0;i<=10;i++){ const x = pad + i*(W-2*pad)/10; ctxLocal.beginPath(); ctxLocal.moveTo(x,pad); ctxLocal.lineTo(x,H-pad); ctxLocal.stroke(); }
  for(let j=0;j<=4;j++){ const y = pad + j*(H-2*pad)/4; ctxLocal.beginPath(); ctxLocal.moveTo(pad,y); ctxLocal.lineTo(W-pad,y); ctxLocal.stroke(); }
}
function catmull(p0,p1,p2,p3,t){
  const t2=t*t, t3=t2*t;
  const x = 0.5*((2*p1.x) + (-p0.x + p2.x)*t + (2*p0.x - 5*p1.x + 4*p2.x - p3.x)*t2 + (-p0.x + 3*p1.x - 3*p2.x + p3.x)*t3);
  const y = 0.5*((2*p1.y) + (-p0.y + p2.y)*t + (2*p0.y - 5*p1.y + 4*p2.y - p3.y)*t2 + (-p0.y + 3*p1.y - 3*p2.y + p3.y)*t3);
  return {x,y};
}
function getPtsFromArrLocal(arr, W, H, pad){
  return arr.map((v,i)=>({x: pad + (i/10)*(W-2*pad), y: H - pad - v*(H-2*pad)}));
}
function drawCurveLocal(ctxLocal, arr, color='#19a6ff', width=3, alpha=1, dashed=false){
  const W = ctxLocal.canvas.width; const H = ctxLocal.canvas.height; const pad = 20;
  drawGrid(ctxLocal, W, H, pad);
  const pts = getPtsFromArrLocal(arr, W, H, pad);
  ctxLocal.beginPath();
  if(dashed) ctxLocal.setLineDash([6,6]); else ctxLocal.setLineDash([]);
  ctxLocal.lineWidth = width; ctxLocal.strokeStyle = color; ctxLocal.globalAlpha = alpha;
  for(let i=0;i<pts.length-1;i++){
    const p0=pts[Math.max(0,i-1)], p1=pts[i], p2=pts[i+1], p3=pts[Math.min(pts.length-1,i+2)];
    for(let t=0;t<=1;t+=0.06){
      const p = catmull(p0,p1,p2,p3,t);
      if(i===0 && t===0) ctxLocal.moveTo(p.x,p.y); else ctxLocal.lineTo(p.x,p.y);
    }
  }
  ctxLocal.stroke();
  ctxLocal.setLineDash([]); ctxLocal.globalAlpha = 1;
  ctxLocal.fillStyle = color; [0,5,10].forEach(idx => { const p = pts[idx]; ctxLocal.beginPath(); ctxLocal.arc(p.x,p.y,3,0,Math.PI*2); ctxLocal.fill(); });
}

function renderGraph(){
  const srcGame = $('src_game').value; const srcCurveKey = $('src_curve').value;
  const mainArr = getCurveArray(srcGame, srcCurveKey);
  drawCurveLocal(ctx, mainArr, '#19a6ff', 3.5, 1, false);
  $('curveLegend').textContent = `${GAME_LABELS[srcGame] || srcGame.toUpperCase()} — ${srcCurveKey.replace(/_/g,' ').toUpperCase()}`;

  if($('compareBtn').classList.contains('active')){
    const tgtGame = $('tgt_game').value;
    const {bestMicro, bestMacro} = findClosestMicroMacro(srcGame, srcCurveKey, tgtGame);
    const matchKey = bestMicro || bestMacro || $('tgt_curve')?.value || 'linear';
    const matchArr = getCurveArray(tgtGame, matchKey);
    // overlay dashed match
    drawCurveLocal(ctx, matchArr, '#00ffd1', 2.6, 0.95, true);
    $('curveLegend').textContent += `  |  Compare (auto): ${GAME_LABELS[tgtGame]||tgtGame.toUpperCase()} — ${matchKey}`;
    // show mini panels
    $('miniWrap').classList.remove('hidden');
    drawCurveLocal(ctxYour, mainArr, '#19a6ff', 2.6, 1, false);
    drawCurveLocal(ctxMatch, matchArr, '#00ffd1', 2.6, 1, false);
  } else {
    $('miniWrap').classList.add('hidden');
  }
}

function updateCompareAvailability(){
  const graphVisible = !$('graphWrap').classList.contains('hidden');
  const srcGame = $('src_game').value, srcCurveKey = $('src_curve').value;
  const tgtGame = $('tgt_game').value;
  const {bestMicro, bestMacro} = findClosestMicroMacro(srcGame, srcCurveKey, tgtGame);
  if(graphVisible && (bestMicro || bestMacro) && (bestMicro !== srcCurveKey || bestMacro !== srcCurveKey)){
    $('compareBtn').classList.remove('hidden');
  } else {
    $('compareBtn').classList.add('hidden'); $('compareBtn').classList.remove('active');
  }
}

/* UI connect */
$('showGraphBtn').addEventListener('click', ()=>{ const wrap = $('graphWrap'); wrap.classList.toggle('hidden'); if(!wrap.classList.contains('hidden')){ renderGraph(); updateCompareAvailability(); } else { $('compareBtn').classList.add('hidden'); $('miniWrap').classList.add('hidden'); } });
$('compareBtn').addEventListener('click', ()=>{ $('compareBtn').classList.toggle('active'); renderGraph(); });
$('src_curve').addEventListener('change', ()=>{ if(!$('graphWrap').classList.contains('hidden')){ renderGraph(); updateCompareAvailability(); }});
$('src_game').addEventListener('change', ()=>{ populateCurves($('src_game').value,'src_curve'); if(!$('graphWrap').classList.contains('hidden')){ renderGraph(); updateCompareAvailability(); }});
$('tgt_game').addEventListener('change', ()=>{ if(!$('graphWrap').classList.contains('hidden')) updateCompareAvailability(); });

$('advToggle').addEventListener('click', ()=> $('advPanel').classList.toggle('hidden'));

/* micro/macro quick toggle (for advanced) */
$('microOn').addEventListener('click', ()=>{ $('microOn').classList.add('active'); $('microOff').classList.remove('active'); /* purely UI: the app runs both but side-by-side labels stay */ });
$('microOff').addEventListener('click', ()=>{ $('microOn').classList.remove('active'); $('microOff').classList.add('active'); });

/* PWA prompt + SW */
let deferredPrompt;
window.addEventListener('beforeinstallprompt',(e)=>{ e.preventDefault(); deferredPrompt=e; $('installBtn').style.display='inline-block'; $('installBtn').addEventListener('click', async ()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); const {outcome} = await deferredPrompt.userChoice; deferredPrompt=null; $('installBtn').style.display='none'; }); });
if('serviceWorker' in navigator){ navigator.serviceWorker.register('service-worker.js').catch(()=>{}); }

/* Debug helper: list candidates & scores */
function logCandidateDistances(srcGame, srcCurveKey, tgtGame){
  const srcArr = getCurveArray(srcGame, srcCurveKey);
  const candidates = GAME_CURVES[tgtGame] || ['linear'];
  const list = candidates.map(k=>{
    const cand = getCurveArray(tgtGame, k);
    const scoreMicro = weightedDistance(srcArr, cand, true);
    const scoreMacro = weightedDistance(srcArr, cand, false);
    return {candidate:k, micro:scoreMicro.toFixed(6), macro:scoreMacro.toFixed(6)};
  }).sort((a,b)=>a.micro - b.micro);
  console.table(list);
  return list;
}
</script>
</body>
</html>
