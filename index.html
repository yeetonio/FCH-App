<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FPS Converter Hub — FCH</title>

  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icon.svg" type="image/svg+xml">
  <meta name="theme-color" content="#19a6ff">

  <!-- Tech font -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="app" class="app" aria-hidden="false" style="display:block;">
    <header class="header" role="banner">
      <div class="left">
        <div class="logo" aria-hidden="true">FCH</div>
        <div>
          <h1 class="title">FPS Converter Hub</h1>
          <div class="sub small">Mobile-first • Controller • Log mapping + true curves</div>
        </div>
      </div>
      <div class="right">
        <button id="installBtn" class="btn-ghost small" aria-label="Install" style="display:none">Install</button>
      </div>
    </header>

    <main class="main" role="main">
      <!-- SOURCE -->
      <section class="card">
        <label class="small">Base Game</label>
        <select id="src_game" class="input" aria-label="Base Game"></select>

        <label class="small">Base Curve (default)</label>
        <select id="src_curve" class="input" aria-label="Base Curve"></select>

        <div class="pair">
          <input id="src_h" class="input half" type="number" value="7" step="any" aria-label="Horizontal sens">
          <input id="src_v" class="input half" type="number" value="7" step="any" aria-label="Vertical sens">
        </div>

        <label class="small">FOV</label>
        <input id="src_fov" class="input" type="number" value="90" aria-label="Field of view" />

        <label class="small checkbox"><input id="adsToggle" type="checkbox"> Include ADS conversion</label>
        <div id="adsFields" class="adsFields hidden">
          <input id="ads_src" class="input" type="text" placeholder=".80 or 80" />
        </div>
      </section>

      <!-- TARGET -->
      <section class="card">
        <label class="small">Target Game</label>
        <select id="tgt_game" class="input" aria-label="Target Game"></select>

        <div style="height:10px"></div>
        <button id="convertBtn" class="btn">Convert</button>
        <div style="height:10px"></div>

        <div style="display:flex;gap:8px;align-items:center">
          <button id="showGraphBtn" class="btn-ghost">Show Graph</button>
          <button id="compareBtn" class="btn-ghost hidden">Compare Curves</button>
        </div>
      </section>

      <!-- OUTPUT + GRAPH -->
      <section class="card">
        <div class="row-between">
          <strong>Conversion Output</strong>
          <div class="small" id="modeTag">Exact Ratio-Based</div>
        </div>

        <div style="height:8px"></div>
        <pre id="output" class="result">Tap Convert</pre>

        <div style="height:10px"></div>
        <button id="advToggle" class="btn-ghost">Advanced</button>
        <div id="advPanel" class="card hidden small">
          <div id="advContent" style="white-space:pre-wrap">Advanced info will appear here.</div>
        </div>

        <div id="graphWrap" class="graph-wrap hidden" aria-live="polite">
          <div id="compareLabel" class="compareLabel hidden"></div>
          <canvas id="curveCanvas" width="720" height="360" aria-label="Curve visualization"></canvas>
          <div class="legend small" id="curveLegend" style="margin-top:8px"></div>
        </div>
      </section>

      <footer class="footer small">Made by Yeetonio — FPS Converter Hub</footer>
    </main>
  </div>

<script>
/* ================= DATA: curves & games ================= */
/* CURVE arrays are 11 sample points from 0..1 (x) -> 0..1 (y) */
const CURVE_SHAPES = {
  linear:[0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1],
  standard:[0,0.02,0.07,0.16,0.29,0.45,0.61,0.76,0.88,0.96,1],
  dynamic:[0,0.01,0.04,0.09,0.18,0.30,0.48,0.70,0.88,0.97,1],
  exponential:[0,0.006,0.02,0.07,0.16,0.33,0.57,0.79,0.92,0.98,1],
  sinusoidal:[0,0.015,0.05,0.12,0.25,0.45,0.66,0.82,0.92,0.98,1],

  /* BF6 derived */
  standard_bf6: [0.00,0.02,0.06,0.12,0.22,0.36,0.52,0.70,0.86,0.96,1.00],
  bf2042_old:    [0.00,0.004,0.015,0.040,0.100,0.250,0.500,0.750,0.900,0.980,1.00],
  bfv:           [0.00,0.018,0.055,0.130,0.250,0.430,0.610,0.780,0.890,0.960,1.00],
  bf1_bf4:       [0.00,0.020,0.060,0.140,0.280,0.440,0.610,0.770,0.900,0.960,1.00],
  bf3:           [0.00,0.03,0.09,0.2,0.35,0.52,0.68,0.82,0.91,0.97,1.00],
  bfbc2:         [0.00,0.028,0.075,0.18,0.33,0.5,0.67,0.81,0.9,0.98,1.00],
  bfbc:          [0.00,0.025,0.07,0.16,0.3,0.48,0.66,0.8,0.9,0.97,1.00],
  dynamic_bf6:   [0.00,0.02,0.06,0.14,0.32,0.22,0.56,0.78,0.92,0.98,1.00],

  /* Apex (sampled from your image) */
  apex_classic:      [0.00,0.03,0.08,0.16,0.26,0.38,0.52,0.68,0.82,0.92,1.00],
  apex_steady:       [0.00,0.01,0.03,0.06,0.12,0.22,0.36,0.52,0.70,0.88,1.00],
  apex_fine_aim:     [0.00,0.02,0.04,0.07,0.10,0.14,0.18,0.22,0.30,0.40,1.00],
  apex_high_velocity:[0.00,0.18,0.40,0.60,0.78,0.90,0.96,0.98,0.995,0.999,1.00],
  apex_linear:       [0.00,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1.00],

  /* MW3 / Warzone sampled */
  mw3_linear:   [0.00,0.04,0.09,0.18,0.32,0.50,0.70,0.85,0.94,0.98,1.00],
  mw3_standard: [0.00,0.02,0.06,0.14,0.25,0.40,0.58,0.74,0.88,0.96,1.00],
  mw3_dynamic:  [0.00,0.01,0.04,0.12,0.28,0.46,0.64,0.80,0.92,0.98,1.00]
};

const GAME_CURVES = {
  mw3:['standard','dynamic','linear'],
  warzone:['standard','dynamic','linear'],
  bo6:['standard','dynamic','linear'],
  bo7:['standard','dynamic','linear'],
  the_finals:['linear','exponential','sinusoidal'],
  bf6:['standard','bf2042_old','bfv','bf1_bf4','bf3','bfbc2','bfbc','linear','dynamic'],
  bf2042:['standard','linear','bf4','bf1','bf3','bfbc','bfbc2','bfv','2042_old'],
  valorant:['standard','linear','light','medium','heavy','extreme'],
  apex:['classic','steady','fine_aim','high_velocity','linear'],
  csgo:['standard'],
  r6:['standard'],
  fragpunk:['standard','linearplus'],
  halo:['standard']
};

const GAME_CURVE_KEYMAP = {
  bf6: { standard:'standard_bf6', bf2042_old:'bf2042_old', bfv:'bfv', bf1_bf4:'bf1_bf4', bf3:'bf3', bfbc2:'bfbc2', bfbc:'bfbc', linear:'linear', dynamic:'dynamic_bf6' },
  apex:{ classic:'apex_classic', steady:'apex_steady', fine_aim:'apex_fine_aim', high_velocity:'apex_high_velocity', linear:'apex_linear' },
  mw3:{ standard:'mw3_standard', dynamic:'mw3_dynamic', linear:'mw3_linear' }
};

const GAME_RANGE = {
  mw3:[1,20,1], warzone:[1,20,1], bf6:[1,100,0.01], bf2042:[1,100,0.01],
  bo6:[0.1,4.0,0.05], bo7:[0.1,4.0,0.05], the_finals:[20,750,5], apex:[1,8,1],
  fragpunk:[0.1,10.0,0.1], halo:[1,20,0.5], r6:[1,100,1], valorant:[1,10,0.01], csgo:[1,10,0.01]
};

const GAME_LABELS = {
  mw3: 'MW3',
  warzone: 'WARZONE',
  bo6: 'BO6',
  bo7: 'BO7',
  the_finals: 'THE FINALS',
  bf6: 'BATTLEFIELD 6',
  bf2042: 'BATTLEFIELD 2042',
  valorant: 'VALORANT',
  apex: 'APEX',
  csgo: 'CS:GO',
  r6: 'R6',
  fragpunk: 'FRAGPUNK',
  halo: 'HALO INFINITE'
};

/* ================= HELPERS / MATH ================= */
function vecDist(a,b){let s=0;for(let i=0;i<11;i++){const d=((a[i]||0)-(b[i]||0));s+=d*d;}return Math.sqrt(s);}
function getCurveArray(game, curveKey){
  if(!game || !curveKey) return CURVE_SHAPES.linear;
  if(GAME_CURVE_KEYMAP[game] && GAME_CURVE_KEYMAP[game][curveKey]) return CURVE_SHAPES[GAME_CURVE_KEYMAP[game][curveKey]];
  return CURVE_SHAPES[curveKey] || CURVE_SHAPES.linear;
}
function findClosest(srcGame,srcCurve,tgtGame){
  const srcArr = getCurveArray(srcGame,srcCurve);
  const candidates = GAME_CURVES[tgtGame] || ['linear'];
  let best=null, bs=1e9;
  candidates.forEach(k=>{
    const cand = getCurveArray(tgtGame,k);
    const sc = vecDist(srcArr,cand);
    if(sc < bs){ bs=sc; best=k; }
  });
  return best||'linear';
}
function logNormalize(value, game){
  const r = GAME_RANGE[game] || [1,100,0.01];
  let v = parseFloat(value);
  if (isNaN(v)) v = r[0];
  v = Math.max(r[0], Math.min(r[1], v));
  const lnMin = Math.log(r[0]+1), lnMax = Math.log(r[1]+1), lnV = Math.log(v+1);
  return (lnV - lnMin) / (lnMax - lnMin);
}
function logDenormalize(norm, game){
  const r = GAME_RANGE[game] || [1,100,0.01];
  const lnMin = Math.log(r[0]+1), lnMax = Math.log(r[1]+1);
  const lnV = lnMin + norm * (lnMax - lnMin);
  const v = Math.exp(lnV) - 1;
  const decimals = (r[1]-r[0]) < 10 ? 2 : 2;
  return parseFloat(Math.max(r[0], Math.min(r[1], v)).toFixed(decimals));
}
function convertController(srcGame,tgtGame,srcSens,srcCurve,srcFov,tgtFov,ads){
  const norm = logNormalize(srcSens, srcGame);
  const baseYaw = {mw3:205,warzone:205,bo6:205,bo7:205,bf6:158,bf2042:158,apex:190,valorant:170,csgo:210,r6:150,fragpunk:180,halo:200,the_finals:178};
  const srcYaw = baseYaw[srcGame] || 180;
  const tgtYaw = baseYaw[tgtGame] || 180;
  const fovFactor = (90/srcFov) / (90/tgtFov);
  let tgtNorm = norm * (srcYaw / tgtYaw) * fovFactor;
  if (ads){
    let a = parseFloat(ads);
    if (a > 1) a = a / 100;
    tgtNorm *= a;
  }
  tgtNorm = Math.max(0, Math.min(1, tgtNorm));
  const tgtSens = logDenormalize(tgtNorm, tgtGame);
  const closest = findClosest(srcGame, srcCurve, tgtGame);
  return {tgtSens, tgtNorm, closest, norm};
}

/* ================= UI ================= */
const $ = id => document.getElementById(id);
function populateGames(){
  const s = $('src_game'), t = $('tgt_game');
  s.innerHTML = ''; t.innerHTML = '';
  Object.keys(GAME_CURVES).forEach(g=>{
    const o = document.createElement('option'); o.value = g; o.textContent = GAME_LABELS[g] || g.toUpperCase(); s.appendChild(o);
    const o2 = document.createElement('option'); o2.value = g; o2.textContent = GAME_LABELS[g] || g.toUpperCase(); t.appendChild(o2);
  });
}
function populateCurves(game, elId){
  const el = $(elId);
  if(!el) return;
  el.innerHTML = '';
  (GAME_CURVES[game]||['linear']).forEach(k=>{
    const o = document.createElement('option');
    let label = k.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
    if (game==='bf6' && k==='dynamic') label = 'Dynamic';
    o.value = k;
    o.textContent = label;
    el.appendChild(o);
  });
}

document.addEventListener('DOMContentLoaded', ()=>{
  populateGames();
  populateCurves($('src_game').value,'src_curve');
  populateCurves($('tgt_game').value,'tgt_curve');

  try{
    const last = JSON.parse(localStorage.getItem('fps_last')||'null');
    if (last){
      if(last.src) $('src_game').value = last.src;
      populateCurves($('src_game').value,'src_curve');
      if(last.srcCurve) $('src_curve').value = last.srcCurve;
      if(last.avg) { $('src_h').value = last.avg; $('src_v').value = last.avg; }
      if(last.fov) $('src_fov').value = last.fov;
      if(last.tgt) { $('tgt_game').value = last.tgt; populateCurves(last.tgt,'tgt_curve'); }
    }
  }catch(e){}

  $('app').style.display='block';
  $('app').removeAttribute('aria-hidden');
});

/* ================= INTERACTIONS ================= */
$('src_game').addEventListener('change', e=> populateCurves(e.target.value,'src_curve'));
$('tgt_game').addEventListener('change', e=> populateCurves(e.target.value,'tgt_curve'));
$('adsToggle').addEventListener('change', e=> $('adsFields').classList.toggle('hidden', !e.target.checked));

$('convertBtn').addEventListener('click', ()=>{
  const src = $('src_game').value, tgt = $('tgt_game').value, srcCurve = $('src_curve').value;
  const h = parseFloat($('src_h').value) || 0, v = parseFloat($('src_v').value) || 0, fov = parseFloat($('src_fov').value) || 90;
  const avg = (h+v)/2; const ads = $('adsToggle').checked ? $('ads_src').value : null;
  const res = convertController(src,tgt,avg,srcCurve,fov,90,ads);
  $('output').textContent = `Source: ${GAME_LABELS[src]||src.toUpperCase()} (${srcCurve}) — Avg ${avg}\nNormalized: ${res.norm.toFixed(4)}\nTarget: ${GAME_LABELS[tgt]||tgt.toUpperCase()} — Closest Curve: ${res.closest}\nSuggested Sens: ${res.tgtSens}`;
  $('advContent').textContent = `Normalized source (0-1): ${res.norm.toFixed(4)}\nTarget normalized (0-1): ${res.tgtNorm.toFixed(4)}\nSuggested target sens: ${res.tgtSens}\nClosest target curve: ${res.closest}`;
  localStorage.setItem('fps_last', JSON.stringify({src,srcCurve,avg,fov,tgt,closest:res.closest}));

  // show compare button if a closest exists and graph is present
  updateCompareAvailability();
});

/* ================= GRAPH & COMPARE ================= */
const canvas = $('curveCanvas');
const ctx = canvas.getContext('2d');

function drawGrid(W,H,pad){
  ctx.fillStyle = '#04101a'; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
  for(let i=0;i<=10;i++){ const x = pad + i*(W-2*pad)/10; ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,H-pad); ctx.stroke(); }
  for(let j=0;j<=4;j++){ const y = pad + j*(H-2*pad)/4; ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(W-pad,y); ctx.stroke(); }
}
function catmull(p0,p1,p2,p3,t){
  const t2=t*t, t3=t2*t;
  const x = 0.5*((2*p1.x) + (-p0.x + p2.x)*t + (2*p0.x - 5*p1.x + 4*p2.x - p3.x)*t2 + (-p0.x + 3*p1.x - 3*p2.x + p3.x)*t3);
  const y = 0.5*((2*p1.y) + (-p0.y + p2.y)*t + (2*p0.y - 5*p1.y + 4*p2.y - p3.y)*t2 + (-p0.y + 3*p1.y - 3*p2.y + p3.y)*t3);
  return {x,y};
}
function getPtsFromArr(arr, W, H, pad){
  return arr.map((v,i)=>({x: pad + (i/10)*(W-2*pad), y: H - pad - v*(H-2*pad)}));
}
function drawCurve(arr, color='#19a6ff', width=3, alpha=1, dashed=false){
  const W = canvas.width = Math.min(window.innerWidth * 0.95, 900);
  const H = canvas.height = 360;
  const pad = 28;
  drawGrid(W,H,pad);
  const pts = getPtsFromArr(arr, W, H, pad);
  ctx.beginPath();
  if(dashed){ ctx.setLineDash([8,6]); } else { ctx.setLineDash([]); }
  ctx.lineWidth = width; ctx.strokeStyle = color; ctx.globalAlpha = alpha;
  for(let i=0;i<pts.length-1;i++){
    const p0 = pts[Math.max(0,i-1)], p1 = pts[i], p2 = pts[i+1], p3 = pts[Math.min(pts.length-1,i+2)];
    for(let t=0;t<=1;t+=0.06){
      const p = catmull(p0,p1,p2,p3,t);
      if(i===0 && t===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
  }
  ctx.stroke();
  ctx.setLineDash([]); ctx.globalAlpha = 1;
  // markers
  ctx.fillStyle = color;
  [0,5,10].forEach(idx => { const p = pts[idx]; ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); });
}

// render single or compare overlay
function renderGraph(){
  const srcGame = $('src_game').value;
  const srcCurveKey = $('src_curve').value;
  const mainArr = getCurveArray(srcGame, srcCurveKey);

  drawCurve(mainArr, '#19a6ff', 3, 1, false);
  $('curveLegend').textContent = `${GAME_LABELS[srcGame] || srcGame.toUpperCase()} — ${srcCurveKey.replace(/_/g,' ').toUpperCase()}`;

  // compare overlay when compare active
  if($('compareBtn').classList.contains('active')){
    const tgtGame = $('tgt_game').value;
    const closest = findClosest(srcGame, srcCurveKey, tgtGame);
    const cmpArr = getCurveArray(tgtGame, closest);
    drawCurve(cmpArr, '#00ffd1', 2.2, 0.85, true);
    $('curveLegend').textContent += `  |  Compare: ${GAME_LABELS[tgtGame]||tgtGame.toUpperCase()} — ${closest}`;
    $('compareLabel').textContent = `Comparing: ${GAME_LABELS[srcGame]||srcGame.toUpperCase()} ${srcCurveKey.replace(/_/g,' ').toUpperCase()}  vs  ${GAME_LABELS[tgtGame]||tgtGame.toUpperCase()} ${closest.replace(/_/g,' ').toUpperCase()}`;
    $('compareLabel').classList.remove('hidden');
  } else {
    $('compareLabel').classList.add('hidden');
  }
}

function updateCompareAvailability(){
  // show compare button only if graph is visible AND a closest exists
  const graphVisible = !$('graphWrap').classList.contains('hidden');
  const srcGame = $('src_game').value;
  const srcCurveKey = $('src_curve').value;
  const tgtGame = $('tgt_game').value;
  const closest = findClosest(srcGame, srcCurveKey, tgtGame);
  // show compare button only if there is a different candidate
  if(graphVisible && closest && closest !== srcCurveKey){
    $('compareBtn').classList.remove('hidden');
  } else {
    $('compareBtn').classList.add('hidden');
    // ensure not active
    $('compareBtn').classList.remove('active');
  }
}

/* UI wiring */
$('showGraphBtn').addEventListener('click', ()=>{
  const wrap = $('graphWrap'); wrap.classList.toggle('hidden');
  if(!wrap.classList.contains('hidden')){ renderGraph(); updateCompareAvailability(); }
  else { $('compareBtn').classList.add('hidden'); $('compareLabel').classList.add('hidden'); }
});
$('compareBtn').addEventListener('click', ()=>{
  // toggle active class and glow
  $('compareBtn').classList.toggle('active');
  renderGraph();
});

// redraw graph on change
$('src_curve').addEventListener('change', ()=>{ if(!$('graphWrap').classList.contains('hidden')){ renderGraph(); updateCompareAvailability(); }});
$('src_game').addEventListener('change', ()=>{ populateCurves($('src_game').value,'src_curve'); if(!$('graphWrap').classList.contains('hidden')){ renderGraph(); updateCompareAvailability(); }});
$('tgt_game').addEventListener('change', ()=>{ if(!$('graphWrap').classList.contains('hidden')) updateCompareAvailability(); });

/* ================= ADVANCED ================= */
$('advToggle').addEventListener('click', ()=> $('advPanel').classList.toggle('hidden'));

/* ================= PWA / INSTALL ================= */
let deferredPrompt;
window.addEventListener('beforeinstallprompt',(e)=>{ e.preventDefault(); deferredPrompt=e; $('installBtn').style.display='inline-block'; $('installBtn').addEventListener('click', async ()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); const {outcome} = await deferredPrompt.userChoice; deferredPrompt=null; $('installBtn').style.display='none'; }); });

/* SERVICE WORKER registration */
if('serviceWorker' in navigator){ navigator.serviceWorker.register('service-worker.js').catch(()=>{}); }
</script>
</body>
</html>
